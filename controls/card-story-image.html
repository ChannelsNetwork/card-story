<dom-module id="card-story-image">
  <template>
    <style>
       :host {
        display: block;
      }

      #imgPanel {
        box-sizing: border-box;
        overflow: hidden;
        transform: translate3d(0, 0, 0);
      }

      .background {
        background: rgba(0, 0, 255, 0.02);
      }

      .fullWidthImage {
        width: 100%;
        box-sizing: border-box;
        display: block;
        transition: transform 0.6s ease, opacity 0.2s ease;
      }
    </style>
    <div id="imgPanel" class="background"></div>
  </template>
  <script>
    class CardStoryImage extends Polymer.Element {
      static get is() { return "card-story-image" }
      static get properties() {
        return {
          data: {
            type: Object,
            observer: '_refresh'
          },
          delegate: {
            type: Object,
            observer: '_onDelegate'
          },
          fullWidth: Boolean
        };
      }

      connectedCallback() {
        super.connectedCallback();
        this._connected = true;
        requestAnimationFrame(() => {
          if (this._connected) {
            this._refresh();
          }
        });
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this._connected = false;
      }

      _onDelegate() {
        this._refresh();
      }

      _refresh() {
        if (this.data && this.delegate && this._connected) {
          this._ensureLaidOut().then(() => {
            let pStyle = this.$.imgPanel.style;
            let imgRatio = this.data.width / this.data.height;
            if (this.fullWidth) {
              pStyle.width = "100%;";
              let w = this.delegate.scrollPanel.offsetWidth;
              let h = Math.min(w / imgRatio, this.delegate.scrollPanel.offsetHeight);
              pStyle.height = h + "px";
            }
            this._attachIntersectionObserver();
          });
        }
      }

      _ensureLaidOut() {
        this._sizeAttempts = 0;
        return new Promise((resolve, reject) => {
          let w = this.offsetWidth;
          if (w) {
            resolve();
          } else {
            var cb = () => {
              this._sizeAttempts++;
              let w = this.offsetWidth;
              if (w) {
                resolve();
              } else {
                if (this._sizeResizeAttempts > 20) {
                  reject();
                } else {
                  setTimeout(cb, 50);
                }
              }
            };
            setTimeout(cb, 50);
          }
        });
      }

      _buildThresholds(steps) {
        let thresholds = [0];
        for (let i = 1.0; i <= steps; i++) {
          thresholds.push(i / steps);
        }
        return thresholds;
      }

      _attachIntersectionObserver() {
        this.delegate.addIntersectionHandler(this.$.imgPanel, this._handleIntersection.bind(this));
      }

      _handleIntersection(entry) {
        this._lastIntersectionEntry = entry;
        if (entry.isIntersecting) {
          if (!(this._imageLoaded || this._imageLoading)) {
            this._loadImage();
            return;
          } else {
            if (this._imageLoaded) {
              this._applyScrollToImage(entry);
            }
          }
        }
      }

      _loadImage() {
        if (this._imageLoading || this._imageLoaded) {
          return;
        }
        this._imageLoading = true;
        let image = new Image();
        this._image = image;
        image.addEventListener("load", () => {
          this._imageLoading = false;
          this._imageLoaded = true;
          console.log("image loaded", image.width, image.height);
          if (this.fullWidth) {
            image.classList.add("fullWidthImage")
          }
          this.$.imgPanel.classList.remove("background");
          this.$.imgPanel.appendChild(image);
          this._applyScrollToImage(this._lastIntersectionEntry);
        });
        image.src = this.data.href;
      }

      _applyScrollToImage(entry) {
        if (entry && this._image) {
          if (entry.isIntersecting) {
            let entering = entry.boundingClientRect.y >= 0;
            let panelWidth = this.$.imgPanel.offsetWidth;
            let panelHeight = this.$.imgPanel.offsetHeight;
            let imgRatio = this.data.width / this.data.height;
            let imgHeight = panelWidth / imgRatio;
            let ir = entry.intersectionRatio;
            if (this.fullWidth && (imgHeight > panelHeight)) {
              let diff = (imgHeight - panelHeight);
              let gain = 0;
              if (entering) {
                if (ir > 0.2 && ir <= 0.9) {
                  gain = (5 / 7) * ir - (1 / 7);
                } else if (ir > 0.9) {
                  gain = 0.5;
                }
              } else {
                if (ir < 0.1) {
                  gain = 1;
                } else if (ir >= 0.7) {
                  gain = 0.5;
                } else {
                  gain = (-5 / 6) * ir + (13 / 12);
                }
              }
              let offset = diff * gain;
              this._image.style.transform = "translate3d(0," + (-offset + "px") + ",0)";
            }
            let opacity = (ir < 0.4) ? ((9 / 4) * ir + 0.1) : 1;
            this._image.style.opacity = opacity;
          }
        }
      }
    }
    window.customElements.define(CardStoryImage.is, CardStoryImage);
  </script>
</dom-module>