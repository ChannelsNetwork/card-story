<dom-module id="card-story-image">
  <template>
    <style>
       :host {
        display: block;
      }

      #imgPanel {
        box-sizing: border-box;
        overflow: hidden;
        transform: translate3d(0, 0, 0);
      }

      .background {
        background: rgba(0, 0, 255, 0.02);
      }

      img {
        display: block;
        box-sizing: border-box;
        margin: 0 auto;
        transition: transform 0.6s ease, opacity 0.2s ease;
      }

      .flowingImage {
        max-width: 100%;
      }

      .fullWidthImage {
        width: 100%;
      }
    </style>
    <div id="imgPanel" class="background"></div>
  </template>
  <script>
    class CardStoryImage extends Polymer.Element {
      static get is() { return "card-story-image" }
      static get properties() {
        return {
          data: {
            type: Object,
            observer: '_refresh'
          },
          delegate: {
            type: Object,
            observer: '_onDelegate'
          },
          width: {
            type: String,
            value: "300px",
          },
          height: {
            type: String,
            value: "300px",
          },
          type: String
        };
      }

      connectedCallback() {
        super.connectedCallback();
        this._connected = true;
        requestAnimationFrame(() => {
          if (this._connected) {
            this._refresh();
          }
        });
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this._connected = false;
      }

      _onDelegate() {
        this._refresh();
      }

      _refresh() {
        if (this.data && this.delegate && this._connected) {
          this._ensureLaidOut().then(() => {
            let pStyle = this.$.imgPanel.style;
            let imgRatio = this.data.width / this.data.height;
            switch (this.type) {
              case "fullWidth": {
                pStyle.width = "100%;";
                let w = this.delegate.scrollPanel.offsetWidth;
                let h = Math.min(w / imgRatio, this.delegate.scrollPanel.offsetHeight);
                pStyle.height = h + "px";
                break;
              }
              case "sized":
                pStyle.width = this.width
                pStyle.height = this.height;
                pStyle.margin = "0 auto";
                break;
              case "page":
                pStyle.width = "100vw";
                pStyle.height = "100vh";
                break;
              default:
                break;
            }
            this._attachIntersectionObserver();
          });
        }
      }

      _ensureLaidOut() {
        this._sizeAttempts = 0;
        return new Promise((resolve, reject) => {
          let w = this.offsetWidth;
          if (w) {
            resolve();
          } else {
            var cb = () => {
              this._sizeAttempts++;
              let w = this.offsetWidth;
              if (w) {
                resolve();
              } else {
                if (this._sizeResizeAttempts > 20) {
                  reject();
                } else {
                  setTimeout(cb, 50);
                }
              }
            };
            setTimeout(cb, 50);
          }
        });
      }

      _buildThresholds(steps) {
        let thresholds = [0];
        for (let i = 1.0; i <= steps; i++) {
          thresholds.push(i / steps);
        }
        return thresholds;
      }

      _attachIntersectionObserver() {
        this.delegate.addIntersectionHandler(this.$.imgPanel, this._handleIntersection.bind(this));
      }

      _handleIntersection(entry) {
        this._lastIntersectionEntry = entry;
        if (entry.isIntersecting) {
          if (!(this._imageLoaded || this._imageLoading)) {
            this._loadImage();
            return;
          } else {
            if (this._imageLoaded) {
              this._applyScrollToImage(entry);
            }
          }
        }
      }

      _loadImage() {
        if (this._imageLoading || this._imageLoaded) {
          return;
        }
        this._imageLoading = true;
        let image = new Image();
        let panelWidth = this.$.imgPanel.offsetWidth;
        let panelHeight = this.$.imgPanel.offsetHeight;
        let imgRatio = this.data.width / this.data.height;
        switch (this.type) {
          case "fullWidth": {
            image.classList.add("fullWidthImage")
            let imgHeight = panelWidth / imgRatio;
            this._imageIsPortrait = imgHeight > panelHeight;
            break;
          }
          case "page":
          case "sized": {
            image.classList.add("sizedImage");
            let imW = panelWidth;
            let imH = imW / imgRatio;
            this._imageIsPortrait = true;
            if (imH < panelHeight) {
              imH = panelHeight;
              imW = imH * imgRatio;
              this._imageIsPortrait = false;
            }
            image.style.width = imW + "px";
            image.style.height = "auto";
            break;
          }
          default:
            image.classList.add("flowingImage");
            break;
        }
        this._image = image;
        image.addEventListener("load", () => {
          this._imageLoading = false;
          this._imageLoaded = true;
          this.$.imgPanel.classList.remove("background");
          this.$.imgPanel.appendChild(image);
          this._applyScrollToImage(this._lastIntersectionEntry);
        });
        image.src = this.data.href;
      }

      _applyScrollToImage(entry) {
        if (entry && this._image) {
          if (entry.isIntersecting) {
            let entering = entry.boundingClientRect.y >= 0;
            let panelWidth = this.$.imgPanel.offsetWidth;
            let panelHeight = this.$.imgPanel.offsetHeight;
            let imgRatio = this.data.width / this.data.height;
            let scrollDirection = 0;
            let scrollDiff = 0;
            switch (this.type) {
              case "fullWidth":
                if (this._imageIsPortrait) {
                  scrollDirection = 1;
                  let imgHeight = panelWidth / imgRatio;
                  scrollDiff = imgHeight - panelHeight;
                }
                break;
              case "page":
              case "sized":
                scrollDirection = this._imageIsPortrait ? 1 : 2;
                if (this._imageIsPortrait) {
                  let imgHeight = panelWidth / imgRatio;
                  scrollDiff = imgHeight - panelHeight;
                } else {
                  let imgWidth = panelHeight * imgRatio;
                  scrollDiff = imgWidth - panelWidth;
                }
                break;
              default:
                break;
            }
            let ir = entry.intersectionRatio;
            if (scrollDirection) {
              let diff = scrollDiff;
              let gain = 0;
              if (entering) {
                if (ir > 0.2 && ir <= 0.9) {
                  gain = (5 / 7) * ir - (1 / 7);
                } else if (ir > 0.9) {
                  gain = 0.5;
                }
              } else {
                if (ir < 0.1) {
                  gain = 1;
                } else if (ir >= 0.7) {
                  gain = 0.5;
                } else {
                  gain = (-5 / 6) * ir + (13 / 12);
                }
              }
              let offset = diff * gain;
              if (scrollDirection == 1) {
                this._image.style.transform = "translate3d(0," + (-offset + "px") + ",0)";
              } else {
                this._image.style.transform = "translate3d(" + (-offset + "px") + ",0,0)";
              }
            }
            let opacity = (ir < 0.4) ? ((9 / 4) * ir + 0.1) : 1;
            this._image.style.opacity = opacity;
          }
        }
      }
    }
    window.customElements.define(CardStoryImage.is, CardStoryImage);
  </script>
</dom-module>